import{d as T}from"./DuAV58dt.js";import{O as w,u as B,a2 as V,Q as S,E as W,a3 as j,D as q,r as x,G as M,a4 as z,a5 as G,a1 as I,L as N,a6 as A,R as Q,a7 as U,c as J,a8 as X,a9 as Y,aa as Z}from"./B7Bdb3zK.js";function ra(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;$(a[0],a[1])&&a.unshift(e);let[l,o,r={}]=a,v=!1;const s=w(()=>A(l));if(typeof s.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=B();r.server??=!0,r.default??=k,r.getCachedData??=H,r.lazy??=!1,r.immediate??=!0,r.deep??=V.deep,r.dedupe??="cancel",r._functionName,t._asyncData[s.value];function y(){const u={cause:"initial",dedupe:r.dedupe};return t._asyncData[s.value]?._init||(u.cachedData=r.getCachedData(s.value,t,{cause:"initial"}),t._asyncData[s.value]=R(t,s.value,o,r,u.cachedData)),()=>t._asyncData[s.value].execute(u)}const m=y(),n=t._asyncData[s.value];n._deps++;const D=r.server!==!1&&t.payload.serverRendered;{let u=function(c){const i=t._asyncData[c];i?._deps&&(i._deps--,i._deps===0&&i?._off())};const d=Q();if(d&&D&&r.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const c=d._nuxtOnBeforeMountCbs;U(()=>{c.forEach(i=>{i()}),c.splice(0,c.length)}),J(()=>c.splice(0,c.length))}const C=d&&(d._nuxtClientOnly||X(Y,!1));D&&t.isHydrating&&(n.error.value||n.data.value!==void 0)?n.status.value=n.error.value?"error":"success":d&&(!C&&t.payload.serverRendered&&t.isHydrating||r.lazy)&&r.immediate?d._nuxtOnBeforeMountCbs.push(m):r.immediate&&n.status.value!=="success"&&m();const f=q(),_=S(s,(c,i)=>{if((c||i)&&c!==i){v=!0;const P=t._asyncData[i]?.data.value!==void 0,L=t._asyncDataPromises[i]!==void 0,O={cause:"initial",dedupe:r.dedupe};if(!t._asyncData[c]?._init){let E;i&&P?E=t._asyncData[i].data.value:(E=r.getCachedData(c,t,{cause:"initial"}),O.cachedData=E),t._asyncData[c]=R(t,c,o,r,E)}t._asyncData[c]._deps++,i&&u(i),(r.immediate||P||L)&&t._asyncData[c].execute(O),Z(()=>{v=!1})}},{flush:"sync"}),b=r.watch?S(r.watch,()=>{v||n._execute({cause:"watch",dedupe:r.dedupe})}):()=>{};f&&W(()=>{_(),b(),u(s.value)})}const h={data:p(()=>t._asyncData[s.value]?.data),pending:p(()=>t._asyncData[s.value]?.pending),status:p(()=>t._asyncData[s.value]?.status),error:p(()=>t._asyncData[s.value]?.error),refresh:(...u)=>t._asyncData[s.value]?._init?t._asyncData[s.value].execute(...u):y()(),execute:(...u)=>h.refresh(...u),clear:()=>{const u=t._asyncData[s.value];if(u?._abortController)try{u._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{u._abortController=void 0}F(t,s.value)}},g=Promise.resolve(t._asyncDataPromises[s.value]).then(()=>h);return Object.assign(g,h),g}function p(a){return w({get(){return a()?.value},set(e){const l=a();l&&(l.value=e)}})}function $(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}async function sa(a){await new Promise(l=>j(l)),await B().hooks.callHookParallel("app:data:refresh",void 0)}function F(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=N(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function K(a,e){const l={};for(const o of e)l[o]=a[o];return l}function R(a,e,l,o,r){a.payload._errors[e]??=void 0;const v=o.getCachedData!==H,s=l,t=o.deep?x:M,y=r!==void 0,m=a.hook("app:data:refresh",async D=>{(!D||D.includes(e))&&await n.execute({cause:"refresh:hook"})}),n={data:t(y?r:o.default()),pending:w(()=>n.status.value==="pending"),error:z(a.payload._errors,e),status:M("idle"),execute:(...D)=>{const[h,g=void 0]=D,u=h&&g===void 0&&typeof h=="object"?h:{};if(a._asyncDataPromises[e]&&(u.dedupe??o.dedupe)==="defer")return a._asyncDataPromises[e];{const f="cachedData"in u?u.cachedData:o.getCachedData(e,a,{cause:u.cause??"refresh:manual"});if(f!==void 0)return a.payload.data[e]=n.data.value=f,n.error.value=void 0,n.status.value="success",Promise.resolve(f)}n._abortController&&n._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),n._abortController=new AbortController,n.status.value="pending";const d=new AbortController,C=new Promise((f,_)=>{try{const b=u.timeout??o.timeout,c=aa([n._abortController?.signal,u?.signal],d.signal,b);if(c.aborted){const i=c.reason;_(i instanceof Error?i:new DOMException(String(i??"Aborted"),"AbortError"));return}return c.addEventListener("abort",()=>{const i=c.reason;_(i instanceof Error?i:new DOMException(String(i??"Aborted"),"AbortError"))},{once:!0,signal:d.signal}),Promise.resolve(s(a,{signal:c})).then(f,_)}catch(b){_(b)}}).then(async f=>{let _=f;o.transform&&(_=await o.transform(f)),o.pick&&(_=K(_,o.pick)),a.payload.data[e]=_,n.data.value=_,n.error.value=void 0,n.status.value="success"}).catch(f=>{if(!(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==C)&&!n._abortController?.signal.aborted){if(typeof DOMException<"u"&&f instanceof DOMException&&f.name==="AbortError"){n.status.value="idle";return}n.error.value=I(f),n.data.value=N(o.default()),n.status.value="error"}}).finally(()=>{d.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=C,a._asyncDataPromises[e]},_execute:T((...D)=>n.execute(...D),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{m(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),v||G(()=>{a._asyncData[e]?._init||(F(a,e),n.execute=()=>Promise.resolve())})}};return n}const k=()=>{},H=(a,e,l)=>{if(e.isHydrating)return e.payload.data[a];if(l.cause!=="refresh:manual"&&l.cause!=="refresh:hook")return e.static.data[a]};function aa(a,e,l){const o=a.filter(s=>!!s);if(typeof l=="number"&&l>=0){const s=AbortSignal.timeout?.(l);s&&o.push(s)}if(AbortSignal.any)return AbortSignal.any(o);const r=new AbortController;for(const s of o)if(s.aborted){const t=s.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}return r.signal}const v=()=>{const t=o.find(y=>y.aborted)?.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}};for(const s of o)s.addEventListener?.("abort",v,{once:!0,signal:e});return r.signal}export{sa as r,ra as u};
